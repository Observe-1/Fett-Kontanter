{"ast":null,"code":"export var snapPoint = function () {\n  var _f = function _f(value, velocity, points) {\n    var point = value + 0.2 * velocity;\n    var deltas = points.map(function (p) {\n      return Math.abs(point - p);\n    });\n    var minDelta = Math.min.apply(null, deltas);\n    return points.filter(function (p) {\n      return Math.abs(point - p) === minDelta;\n    })[0];\n  };\n\n  _f._closure = {};\n  _f.asString = \"function snapPoint(value,velocity,points){var point=value+0.2*velocity;var deltas=points.map(function(p){return Math.abs(point-p);});var minDelta=Math.min.apply(null,deltas);return points.filter(function(p){return Math.abs(point-p)===minDelta;})[0];}\";\n  _f.__workletHash = 3848343866657;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();","map":{"version":3,"sources":["Physics.ts"],"names":["snapPoint","point","value","deltas","points","Math","minDelta"],"mappings":"AAIA,OAAO,IAAMA,SAAAA;AAAAA,uBAAY,KAAZA,EAAY,QAAZA,EAAY,MAAZA,EAIA;AAEX,QAAMC,KAAK,GAAGC,KAAK,GAAG,MAAtB,QAAA;AACA,QAAMC,MAAM,GAAGC,MAAM,CAANA,GAAAA,CAAW,UAAA,CAAA,EAAA;AAAA,aAAOC,IAAI,CAAJA,GAAAA,CAASJ,KAAK,GAArB,CAAOI,CAAP;AAA1B,KAAeD,CAAf;AACA,QAAME,QAAQ,GAAGD,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAjB,MAAiBA,CAAjB;AACA,WAAOD,MAAM,CAANA,MAAAA,CAAc,UAAA,CAAA,EAAA;AAAA,aAAOC,IAAI,CAAJA,GAAAA,CAASJ,KAAK,GAAdI,CAAAA,MAAP,QAAA;AAAdD,KAAAA,EAAP,CAAOA,CAAP;AATK,GAAMJ;;AAAAA;AAAAA;AAAAA;;AAAAA;;AAAAA;AAAAA,GAAN","sourcesContent":["/**\n * @summary Select a point where the animation should snap to given the value of the gesture and it's velocity.\n * @worklet\n */\nexport const snapPoint = (\n  value: number,\n  velocity: number,\n  points: ReadonlyArray<number>\n): number => {\n  \"worklet\";\n  const point = value + 0.2 * velocity;\n  const deltas = points.map((p) => Math.abs(point - p));\n  const minDelta = Math.min.apply(null, deltas);\n  return points.filter((p) => Math.abs(point - p) === minDelta)[0];\n};\n"]},"metadata":{},"sourceType":"module"}